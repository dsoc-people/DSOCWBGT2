# -*- coding: utf-8 -*-
"""Working code_Mapped

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dvvrhiICfwBMTNmakp0sEL-RV47pcK_B
"""

import requests
import pandas as pd
import numpy as np
import json

# --- Configuration ---
year = "2025" # Year is now a general configuration

# --- Helper function for unit conversion (from the provided code) ---
def farenheit_to_celsius(temp_f):
    return (temp_f - 32) * 5 / 9

def celsius_to_farenheit(temp_c):
    return temp_c * 9 / 5 + 32

# --- Wet Bulb Temperature Calculation (simplified, based on provided context) ---
# Note: A full wet bulb calculation is complex and often uses iterative methods.
# This is a simplified approach based on the structure of the provided code snippet.
# For a more accurate calculation, a dedicated psychrometric library might be needed.
def dbdp2wb(tempC, dpC, p):
    # This is a placeholder function based on the name in the user's code.
    # A proper implementation would require more complex psychrometric calculations.
    # For demonstration, we'll use a simple approximation or return a placeholder value.
    # In a real-world scenario, you'd replace this with a robust calculation.
    # A common approximation is the Stull formula or others.
    # As a placeholder, let's return an average of dry bulb and dew point as a very rough estimate.
    # This needs to be replaced with a real psychrometric calculation.
    return (tempC + dpC) / 2 # Placeholder - Replace with actual calculation


# --- Wet Bulb Globe Temperature Calculation (from the provided code structure) ---
def wbgt(tempF, mph, rad, bar, dpF):
    # tempF = dry bulb temp F
    # mph = wind speed in mph
    # rad = solar radiation in W/m^2
    # bar = pressure in in Hg
    # dpF = dewpoint temp in F

    # #1 - GLOBE TEMPERATURE
    tempC = farenheit_to_celsius(tempF)
    mps = mph * 0.44704
    tempK = tempC + 273.15

    # Ensure rad is not None or NaN before calculation
    if rad is None or np.isnan(rad):
        tempG = np.nan
    else:
        # Add a small epsilon to the denominator to avoid division by zero if rad is close to 0
        tempG = tempK + (rad - 30) / (0.0252 * rad + 10.5 * mps + 22.5 + 1e-9)
        tempG = tempG - 273.15 # Globe Temp in deg C

    # #2 - WET BULB TEMPERATURE
    # convert pressure in inches Hg to kilo-pascals
    p = bar * 3.38639

    # convert dewpoint to C
    dpC = farenheit_to_celsius(dpF)

    # Ensure inputs for dbdp2wb are not None or NaN
    if np.isnan(tempC) or np.isnan(dpC) or np.isnan(p):
         wbc = np.nan
    else:
        wbc = dbdp2wb(tempC, dpC, p)


    if np.isnan(wbc) or np.isnan(tempG) or np.isnan(tempC):
        wbgt_c = np.nan
    else:
        wbgt_c = 0.7 * wbc + 0.2 * tempG + 0.1 * tempC

    wbgt_f = celsius_to_farenheit(wbgt_c)

    # return WBGT in degrees F
    return wbgt_f


# Function to fetch data and calculate WBGT for a single station
def process_station_data(station_id, year, station_coords):
    try:
        # --- Step 1: Get the station's data manifest ---
        manifest_url = f"https://d266k7wxhw6o23.cloudfront.net/data/{station_id}/{year}/manifest.json"
        manifest = requests.get(manifest_url).json()

        # --- Step 2: Find the most recent file ---
        latest_day = max(manifest.keys())
        latest_key = manifest[latest_day]["key"]
        data_url = f"https://d266k7wxhw6o23.cloudfront.net/{latest_key}"
        #print(f"Loading latest data file for {station_id}: {data_url}") # Uncomment for debugging

        # --- Step 3: Load the latest data file ---
        data = requests.get(data_url).json()

        # --- Step 4: Convert JSON to DataFrame for easier handling ---
        df = pd.DataFrame(data['rows'], columns=data['columns'])

        # --- Step 5: Extract relevant data ---
        required_columns = ["TAIR", "DWPT", "WSPD", "SRAD", "PRES", "UTCTimestampCollected"]
        if not all(col in df.columns for col in required_columns):
            print(f"Warning: Missing required columns for station {station_id}. Skipping WBGT calculation.")
            return None

        last_valid_indices = {col: df[col].last_valid_index() for col in required_columns}

        tair_c = np.nan
        dwpt_c = np.nan
        wspd_mps = np.nan
        srad = np.nan
        pres_inhg = np.nan
        observation_time = "N/A"


        if last_valid_indices["TAIR"] is not None:
            tair_c = df.loc[last_valid_indices["TAIR"], "TAIR"]

        if last_valid_indices["DWPT"] is not None:
            dwpt_c = df.loc[last_valid_indices["DWPT"], "DWPT"]

        if last_valid_indices["WSPD"] is not None:
            wspd_mps = df.loc[last_valid_indices["WSPD"], "WSPD"]

        if last_valid_indices["SRAD"] is not None:
            srad = df.loc[last_valid_indices["SRAD"], "SRAD"]

        if last_valid_indices["PRES"] is not None:
            pres_hpa = df.loc[last_valid_indices["PRES"], "PRES"]
            pres_inhg = pres_hpa * 0.02953
        else:
            print(f"Warning: Pressure data not available for station {station_id}. Cannot calculate WBGT.")
            return None

        if last_valid_indices["UTCTimestampCollected"] is not None:
            observation_time = df.loc[last_valid_indices["UTCTimestampCollected"], "UTCTimestampCollected"]


        # Convert units
        tair_f = celsius_to_farenheit(tair_c) if not np.isnan(tair_c) else np.nan
        dwpt_f = celsius_to_farenheit(dwpt_c) if not np.isnan(dwpt_c) else np.nan
        wspd_mph = wspd_mps * 2.23694 if not np.isnan(wspd_mps) else np.nan

        # --- Step 6: Calculate WBGT ---
        wbgt_f = np.nan
        if not np.isnan(tair_f) and not np.isnan(wspd_mph) and not np.isnan(srad) and not np.isnan(pres_inhg) and not np.isnan(dwpt_f):
            wbgt_f = wbgt(tair_f, wspd_mph, srad, pres_inhg, dwpt_f)
        else:
            print(f"Warning: Not all required data for WBGT calculation is available for station {station_id}.")
            return None

        # Get latitude and longitude from the station_coords dictionary
        latitude, longitude = station_coords.get(station_id, (None, None))

        return {
            "name": station_id,
            "latitude": latitude,
            "longitude": longitude,
            "wbgt_f": wbgt_f,
            "observation_time": observation_time
        }

    except Exception as e:
        print(f"Error processing station {station_id}: {e}")
        return None

# List to store WBGT results for each station
wbgt_results = []

# Iterate through the list of station abbreviations and process each one
for station_id in station_abbreviations:
    station_data = process_station_data(station_id, year, station_coords) # Pass station_coords
    if station_data:
        wbgt_results.append(station_data)

# Convert results to a DataFrame
wbgt_df = pd.DataFrame(wbgt_results)

# Display the results
display(wbgt_df)

station_abbreviations_text = """FARM
RSVL
MRHD
MRRY
PCWN
HTFD
CMBA
CRMT
LXGN
BLRK
SCTV
PRNC
BMBL
PGHL
LSML
ERLN
OLIN
QKSD
SWON
LGNT
MROK
PVRT
BNGL
CRRL
HRDB
FRNY
GRDR
RPTN
ELST
DRFN
BTCK
WLBT
WSHT
WNCH
CCLA
BNVL
RNDH
HCKM
RBSN
HHTS
PRYB
"""

# Split the text into a list of station abbreviations
station_abbreviations = [abbrev.strip() for abbrev in station_abbreviations_text.splitlines() if abbrev.strip()]

print(f"Processing {len(station_abbreviations)} stations:")
print(station_abbreviations)

# Commented out IPython magic to ensure Python compatibility.
# Install folium for mapping
# %pip install folium -q

import folium

# Create a map centered around the average location of the stations
# Calculate the average latitude and longitude
avg_lat = wbgt_df['latitude'].mean() if not wbgt_df['latitude'].isnull().all() else 0
avg_lon = wbgt_df['longitude'].mean() if not wbgt_df['longitude'].isnull().all() else 0

m = folium.Map(location=[avg_lat, avg_lon], zoom_start=7)

# Add markers for each station with WBGT information in the tooltip
for index, row in wbgt_df.iterrows():
    if pd.notna(row['latitude']) and pd.notna(row['longitude']):
        folium.Marker(
            location=[row['latitude'], row['longitude']],
            popup=f"<b>{row['name']}</b><br>WBGT: {row['wbgt_f']:.1f} °F<br>Time: {row['observation_time']}",
            tooltip=f"{row['name']}: {row['wbgt_f']:.1f} °F"
        ).add_to(m)

# Display the map
m

station_coords_text = """FARM,36.93,-86.47
RSVL,36.85,-86.92
MRHD,38.22,-83.48
MRRY,36.61,-88.34
PCWN,37.28,-84.96
HTFD,37.45,-86.89
CMBA,37.12,-85.31
CRMT,37.94,-85.67
LXGN,37.93,-84.53
BLRK,37.47,-86.33
SCTV,36.74,-86.21
PRNC,37.09,-87.86
BMBL,36.86,-83.84
PGHL,36.94,-87.48
LSML,38.08,-84.90
ERLN,37.32,-87.49
OLIN,37.36,-83.96
QKSD,37.54,-83.32
SWON,38.53,-84.77
LGNT,37.54,-84.63
MROK,36.95,-85.99
PVRT,37.54,-87.28
BNGL,37.36,-85.49
CRRL,38.67,-85.15
HRDB,37.77,-84.82
FRNY,37.72,-87.90
GRDR,36.79,-85.45
RPTN,37.36,-88.07
ELST,37.71,-84.18
DRFN,36.88,-88.32
BTCK,37.01,-88.96
WLBT,37.83,-85.96
WSHT,37.97,-82.50
WNCH,38.01,-84.13
CCLA,36.67,-88.67
BNVL,37.28,-84.67
RNDH,37.45,-82.99
HCKM,36.85,-88.34
RBSN,37.42,-83.02
HHTS,36.96,-85.64
PRYB,36.83,-83.17
CADZ,36.83,-87.86
ALBN,36.71,-85.14
HUEY,38.97,-84.72
VEST,37.41,-82.99
GRHM,37.82,-87.51
MQDY,37.71,-86.50
CLSL,38.28,-84.10
CHTR,38.58,-83.42
FLRK,36.77,-84.48
DORT,37.28,-82.52
FCHV,38.16,-85.38
LGRN,38.46,-85.47
HDYV,37.26,-85.78
LUSA,38.10,-82.60
PRST,38.09,-83.76
BRND,37.95,-86.22
LRTO,37.63,-85.37
HDGV,37.57,-85.70
WTBG,37.13,-82.84
SWZR,36.67,-86.61
CCTY,37.29,-87.16
ZION,36.76,-87.21
PSPG,37.01,-86.37
BMTN,36.92,-82.91
WDBY,37.18,-86.65
DANV,37.62,-84.82
CROP,38.33,-85.17
HARD,37.76,-86.46
GAMA,36.66,-85.80
DABN,37.18,-84.56
DIXO,37.52,-87.69
WADD,38.09,-85.14
EWPK,37.04,-86.35
RFVC,37.46,-83.16
RFSM,37.43,-83.18
CARL,38.32,-84.04
MONT,36.87,-84.90
BAND,37.13,-88.95
WOOD,36.99,-84.97
DCRD,37.87,-83.65
SPIN,38.13,-84.50
GRBG,37.21,-85.47
PBDY,37.14,-83.58
BLOM,37.96,-85.31
LEWP,37.92,-86.85
STAN,37.85,-83.88
BEDD,38.63,-85.32
"""

# Parse the text into a dictionary of station coordinates
station_coords = {}
station_abbreviations = []
for line in station_coords_text.strip().splitlines():
    parts = line.split(',')
    if len(parts) == 3:
        abbrev = parts[0].strip()
        try:
            lat = float(parts[1].strip())
            lon = float(parts[2].strip())
            station_coords[abbrev] = (lat, lon)
            station_abbreviations.append(abbrev)
        except ValueError:
            print(f"Skipping invalid line: {line}")

print(f"Parsed coordinates for {len(station_coords)} stations.")
print(f"Processing {len(station_abbreviations)} stations:")